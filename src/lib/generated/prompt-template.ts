const PROMPT_TEMPLATE =
    "I want you to convert an AngularJS component into a functional React component.\n\n## General Rules:\n\n-   You should explain any assumptions you have made\n-   Highlight any potential issues\n-   So that I can programmatically find your code, please top and tail it with `// ___NG2R_START___` and `// ___NG2R_END___`,\n-   The output should be in ${LANGUAGE}\n\n**Example Response**\n\n```jsx\n// ___NG2R_START___\n\nimport React from 'react'\n\n// Assumption 1: One-way bindings should be converted to read-only elements, as they are not meant to be modified by the user.\n\nconst MyComponent = ({ myProp }) => {\n    return (\n        <div>\n            <h1>Title: {myProp}</h1>\n        </div>\n    )\n}\n\n/**\n * Potential issues:\n * 1. Since AngularJS uses two-way data binding by default, converting to React requires handling state updates manually. This can lead to more complex code and potential issues if not handled correctly.\n */\n\n// ___NG2R_END___\n```\n\n## Code Patterns\n\nI want you to deal with certain code patterns in a specific way. Here are the patterns I want you to deal with:\n\n### Pattern 1: Two-way bindings\n\n-   Assume that state is managed by the parent component\n-   Assume that the parent component will pass down a callback function to update the state\n-   Do not use `useState` to manage state locally\n\n**Example:**\n\n```jsx\nconst StateBindingExample = ({ twoWayBinding, onTwoWayBindingChange }) => {\n    const handleTwoWayBindingChange = (e) => {\n        onTwoWayBindingChange(e.target.checked)\n    }\n\n    return (\n        <div>\n            <label>\n                2-Way Binding <input type=\"checkbox\" checked={twoWayBinding} onChange={handleTwoWayBindingChange} />\n            </label>\n        </div>\n    )\n}\n```\n\n### Pattern 2: One-way bindings / String Bindings\n\n-   If the value does not appear to be modifyed, assume that it is read-only; otherwise\n-   Create a local state variable using `useState` and update it using `useEffect` declaring the initial state as a dependency\n\n**Example:**\n\n```jsx\nconst StateBindingExample = ({ oneWayBinding: initialOneWayBinding, readOnlyOneWayBinding }) => {\n    const [oneWayBinding, setOneWayBinding] = useState(initialOneWayBinding)\n\n    useEffect(() => {\n        setOneWayBinding(initialOneWayBinding)\n    }, [initialOneWayBinding])\n\n    return (\n        <div>\n            <div>\n                <label>\n                    1-Way Binding{' '}\n                    <input\n                        type=\"checkbox\"\n                        checked={oneWayBinding}\n                        onChange={(e) => setOneWayBinding(e.target.checked)}\n                    />\n                </label>\n            </div>\n            <div>\n                <label>\n                    Readonly 1-Way Binding <input type=\"checkbox\" checked={readOnlyOneWayBinding} readOnly />\n                </label>\n            </div>\n        </div>\n    )\n}\n```\n\n### Pattern 3: Service Injection\n\n-   If the service name starts with a `$`:\n    -   Assume that it is a built-in AngularJS service\n    -   Assume that a non-angular equivalent is available\n-   Use a custom hook called `useService` to inject the service\n\n**Example:**\n\n```jsx\nconst ServiceInjectionExample = ({}) => {\n    const myService = useService('myService')\n    // Assumption: New non-angular service called 'httpService' can be used instead of '$http'\n    const httpService = useService('httpService')\n\n    return <>...</>\n}\n```\n\n### Pattern 4: Require Controller\n\nWhere a controller is required, assume that it can be passed in as a prop.\n\n**Example:**\n\n```javascript\nangular.module('myApp').component('myComponent', {\n    require: '^MyController',\n    template: '<div>...</div>',\n})\n```\n\n```jsx\nconst RequireControllerExample = ({ myController }) => {\n    return <>...</>\n}\n```\n\n## The AngularJS Component:\n\n${COMPONENT}\n"
export default PROMPT_TEMPLATE
